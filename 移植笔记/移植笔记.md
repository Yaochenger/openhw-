### 2022.11.15

- core-v-mcu 文档资料

  ```c#
  https://docs.openhwgroup.org/projects/core-v-mcu/index.html
  ```

- cv32e40p与RI5CY的关系

  ```c#
  https://dingfen.github.io/risc-v/verilog/2020/07/16/RI5CY.html
  ```

- 项目目的

  > 移植RT-Thread至core-v-mcu

- 简介

  > - core-v-mcu的内核为cv32e40p
  >
  > - cv32e40p继承自pulp开源的RI5CY内核  pulp是一个开源soc组织
  > - openhw是一个内核开源组织 pulp加入openhw将RI5CY贡献给了openhw
  > - core-v-mcu继承自PULPissimo PULPissimo是pulp维护的一个开源soc平台内核为RI5CY

#### CV32E40P内核与RI5CY内核

- CV32E40P内核：

![](C:\Users\RTT\Desktop\OpenHW移植\figure\CV32E40P_Block_Diagram.png)

- RI5CY内核:

![](C:\Users\RTT\Desktop\OpenHW移植\figure\riscy_archi.png)

#### CORE-V-MCU与PULPissimo

- core-v-mcu

  ![](C:\Users\RTT\Desktop\OpenHW移植\figure\core-v-mcu-block-diagram.png)

- PULLissimo

  ![](C:\Users\RTT\Desktop\OpenHW移植\figure\pulpissimo_archi.png)

- OpenHW移植\core-v-mcu\CV32E40P_User_Manual-master 阅读笔记

  > CV32E40P是一个**顺序**（发射、执行）的**四级**流水线**32位**RISC-V处理器。CV32E40P的指令集包含了一部分的自定义扩展指令集，包括有：硬件循环（hardware loops）、地址自增的访存指令（post-increment load and store）以及额外的一系列ALU指令（算术指令扩展、乘累加MAC、向量操作等等）。core-v-mcu 文档资料

  #### core-v-mcu 文档资料笔记

  ##### core-v-mcu片上外设

   core-v-mcu 的目的是展示OpenHW提供的 cv32e40p 完全验证的 RISC-V 内核。cv32e40p 内核连接到一组具有代表性的外设：

  - 2路串口
  - 2路I2C 主机
  - 1路I2C 从机
  - 2路QSPI 主机
  - 1路相机
  - 1路SDIO
  - 4路PWM
  - eFPGA

  #### 片上外设基地址与偏移

  位于***core-v-mcu-pulp-mem-map.h***文件中

  - 基地址

  ![](C:\Users\RTT\Desktop\OpenHW移植\figure\mem-map1.png)

  + 外设偏移

    ![](C:\Users\RTT\Desktop\OpenHW移植\figure\mem-map2.png)

  + 控制状态寄存器访问类型

![](C:\Users\RTT\Desktop\OpenHW移植\figure\CSR访问类型.png)

#### 片上外设寄存器

- SOC-CTRL

  > 基地址: SOC_CTRL_START_ADDR (0x1A104000)
  >
  > 作用：配置连接在综合总线上的核的数量 、GPIO控制器上连接的IO的数量、UART的数量等，以及表明一些控制器的状态等

- APB_EVENT_CNTRL

  >基地址:: SOC_EVENT_GEN_START_ADDR(SOC_EVENT_START_ADDR)
  >
  >作用： APB 外围设备收集所有呈现给 CPU 的事件作为 IRQ11（机器中断）。每个事件都可以通过 EVENT_MASKx 寄存器中的相应位单独屏蔽。当接收到启用事件（未屏蔽）时，它被放入事件 FIFO 中，并且 IRQ11 信号被提交给 CPU，然后 CPU 可以读取 EVENT FIFO 以确定哪个事件导致中断。每个事件都有一个深度为 4 的队列来收集事件，如果任何事件的队列溢出，则会将错误记录到相应的 EVENT_ERR 寄存器中，并将 IRQ31 提交给 CPU。

- APB_TIMER_UINT

  > 基地址: TIMER_START_ADDDR(0x1A10B000)

- APB_GPIO

  > 基地址: GPIO_START_ADDR(0x1A101000)、

- APB_I2CS

  > 基地址: I2CS_START_ADDR(0x1A107000)

- eFPGA

  > 基地址: EFPGA_ASYNC_APB_START_ADD(EFPGA_ASYNC_APB_START_ADD)

- UDMA_CTRL

  >基地址: UDMA_CH_ADDR_CTRL(`UDMA_CH_ADDR_CTRL)
  >
  >- 启用或禁用外设时钟
  >- 重置外围控制器
  >- 为事件处理机制设置比较值
  >-  ***core-v-mcu-config.h***中定义了UDMA 通道的起始 地址***UDMA_START_ADDR***

- UDMA_UART

  > 基地址:UDMA_CH_ADDR_UART(`UDMA_CH_ADDR_UART)

- UDMA_I2CM

  > 基地址：UDMA_CH_ADDR_I2CM(UDMA_CH_ADDR_I2CM)
  >
  > I2C 控制器的动作是使用发送缓冲区中存在的一系列命令来控制的。因此，要使用 I2C 控制器，软件必须在缓冲区中组装适当的命令序列，并使用 UDMA 将缓冲区发送到 I2C 控制器。由于 UDMA 处理数据缓冲区和中断，了解如何操作 UDMA 控制器非常重要

- UDMA_QSPI

  > 基地址:UDMA_CH_ADDR_QSPI(UDMA_CH_ADDR_QSPI)
  >
  > QSPI 控制器的动作是使用发送缓冲区中存在的一系列命令来控制的。因此，要使用 QSPI 控制器，软件必须在缓冲区中组装适当的命令序列，并使用 UDMA 将缓冲区发送到 QSPI 控制器。由于 UDMA 处理数据缓冲区和中断，了解如何操作 UDMA 控制器非常重要。

- UDMA_SDIO

  > 基地址：UDMA_CH_ADDR_SDIO(`UDMA_CH_ADDR_SDIO)

- UDMA_CAMERA

  > 基地址：UDMA_CH_ADDR_CAMERA(UDMA_CH_ADDR_CAMERA)

#### 串口映射到的管脚

![](C:\Users\RTT\Desktop\OpenHW移植\figure\uart-pin.png)

